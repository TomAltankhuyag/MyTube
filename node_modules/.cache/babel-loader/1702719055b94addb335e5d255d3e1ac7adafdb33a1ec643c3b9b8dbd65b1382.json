{"ast":null,"code":"import { EMPTY, VIDEO_ID_SIZE, WWW, HTTPS } from \"../constants/constants\";\n\n// returns the videoId of the chosen string\n// added some general filtering for a non-trivial invalid videoId detection\nexport async function videoIdParser(chosenString) {\n  if (!hasYoutubeTopLevelDomain(chosenString)) {\n    return chosenString.length === VIDEO_ID_SIZE ? chosenString : EMPTY;\n  }\n  const value = await isValidYoutubeUrl(chosenString).then(isValid => {\n    if (!isValid) {\n      return EMPTY;\n    }\n    const videoId = getVideoIdParam(chosenString);\n    return videoId;\n  }).catch(e => {\n    console.error(e);\n  });\n  console.log(value);\n}\nfunction getVideoIdParam(urlString) {\n  let url = urlString;\n  if (!url.includes(WWW)) {\n    url = WWW + url;\n  }\n  if (!url.includes(HTTPS)) {\n    url = HTTPS + url;\n  }\n  console.log(`url: ${url}`);\n  const params = new URL(url).searchParams;\n  const videoId = params.get('v');\n  console.log(videoId);\n  return videoId;\n}\n\n// Has to be a link with domain\nasync function isValidYoutubeUrl(urlString) {\n  try {\n    // debugger\n    const shift = urlString.includes(WWW) ? urlString.indexOf(WWW) + WWW.length : 0;\n    let youtubeUrl = urlString.substring(shift, urlString.indexOf('/', shift));\n    const filterStrings = ['youtube.com', 'm.youtube.com', 'youtu.be'];\n    if (!youtubeUrl.includes(HTTPS)) {\n      youtubeUrl = HTTPS + youtubeUrl;\n    }\n    const youtubeURLObject = new URL(youtubeUrl);\n    const hostname = youtubeURLObject.hostname;\n    let validUrl = false;\n    filterStrings.every(domainName => {\n      if (hostname === domainName) {\n        validUrl = true;\n        return false;\n      }\n    });\n    return validUrl;\n  } catch (e) {\n    return false;\n  }\n}\nfunction hasYoutubeTopLevelDomain(string) {\n  return string.includes('.com') || string.includes('.be');\n}","map":{"version":3,"names":["EMPTY","VIDEO_ID_SIZE","WWW","HTTPS","videoIdParser","chosenString","hasYoutubeTopLevelDomain","length","value","isValidYoutubeUrl","then","isValid","videoId","getVideoIdParam","catch","e","console","error","log","urlString","url","includes","params","URL","searchParams","get","shift","indexOf","youtubeUrl","substring","filterStrings","youtubeURLObject","hostname","validUrl","every","domainName","string"],"sources":["X:/Coding/MyTube/src/utility/video-id-parser.js"],"sourcesContent":["import { EMPTY, VIDEO_ID_SIZE, WWW, HTTPS } from \"../constants/constants\"\n\n// returns the videoId of the chosen string\n// added some general filtering for a non-trivial invalid videoId detection\nexport async function videoIdParser(chosenString) {\n  if (!hasYoutubeTopLevelDomain(chosenString)) {\n    return chosenString.length === VIDEO_ID_SIZE ? chosenString : EMPTY\n  }\n\n  const value = await isValidYoutubeUrl(chosenString).then(isValid => {\n    if (!isValid) {\n      return EMPTY\n    }\n    const videoId = getVideoIdParam(chosenString)\n    return videoId\n  }).catch(e => {\n    console.error(e)\n  })\n  console.log(value);\n}\n\nfunction getVideoIdParam(urlString) {\n  let url = urlString\n  if (!url.includes(WWW)) {\n    url = WWW + url\n  }\n  if (!url.includes(HTTPS)) {\n    url = HTTPS + url\n  }\n  console.log(`url: ${url}`);\n  const params = new URL(url).searchParams\n\n  const videoId = params.get('v')\n  console.log(videoId);\n  return videoId\n}\n\n// Has to be a link with domain\nasync function isValidYoutubeUrl(urlString) {\n  try {\n    // debugger\n    const shift = urlString.includes(WWW) ? urlString.indexOf(WWW) + WWW.length : 0\n\n    let youtubeUrl = urlString.substring(shift, urlString.indexOf('/', shift))\n    const filterStrings = ['youtube.com', 'm.youtube.com', 'youtu.be']\n\n    if (!youtubeUrl.includes(HTTPS)) {\n      youtubeUrl = HTTPS + youtubeUrl\n    }\n    const youtubeURLObject = new URL(youtubeUrl)\n\n    const hostname = youtubeURLObject.hostname\n    let validUrl = false\n    filterStrings.every((domainName) => {\n      if (hostname === domainName) {\n        validUrl = true\n        return false\n      }\n    })\n    return validUrl\n  } catch (e) {\n    return false\n  }\n\n}\n\nfunction hasYoutubeTopLevelDomain(string) {\n  return string.includes('.com') || string.includes('.be')\n}\n"],"mappings":"AAAA,SAASA,KAAK,EAAEC,aAAa,EAAEC,GAAG,EAAEC,KAAK,QAAQ,wBAAwB;;AAEzE;AACA;AACA,OAAO,eAAeC,aAAaA,CAACC,YAAY,EAAE;EAChD,IAAI,CAACC,wBAAwB,CAACD,YAAY,CAAC,EAAE;IAC3C,OAAOA,YAAY,CAACE,MAAM,KAAKN,aAAa,GAAGI,YAAY,GAAGL,KAAK;EACrE;EAEA,MAAMQ,KAAK,GAAG,MAAMC,iBAAiB,CAACJ,YAAY,CAAC,CAACK,IAAI,CAACC,OAAO,IAAI;IAClE,IAAI,CAACA,OAAO,EAAE;MACZ,OAAOX,KAAK;IACd;IACA,MAAMY,OAAO,GAAGC,eAAe,CAACR,YAAY,CAAC;IAC7C,OAAOO,OAAO;EAChB,CAAC,CAAC,CAACE,KAAK,CAACC,CAAC,IAAI;IACZC,OAAO,CAACC,KAAK,CAACF,CAAC,CAAC;EAClB,CAAC,CAAC;EACFC,OAAO,CAACE,GAAG,CAACV,KAAK,CAAC;AACpB;AAEA,SAASK,eAAeA,CAACM,SAAS,EAAE;EAClC,IAAIC,GAAG,GAAGD,SAAS;EACnB,IAAI,CAACC,GAAG,CAACC,QAAQ,CAACnB,GAAG,CAAC,EAAE;IACtBkB,GAAG,GAAGlB,GAAG,GAAGkB,GAAG;EACjB;EACA,IAAI,CAACA,GAAG,CAACC,QAAQ,CAAClB,KAAK,CAAC,EAAE;IACxBiB,GAAG,GAAGjB,KAAK,GAAGiB,GAAG;EACnB;EACAJ,OAAO,CAACE,GAAG,CAAE,QAAOE,GAAI,EAAC,CAAC;EAC1B,MAAME,MAAM,GAAG,IAAIC,GAAG,CAACH,GAAG,CAAC,CAACI,YAAY;EAExC,MAAMZ,OAAO,GAAGU,MAAM,CAACG,GAAG,CAAC,GAAG,CAAC;EAC/BT,OAAO,CAACE,GAAG,CAACN,OAAO,CAAC;EACpB,OAAOA,OAAO;AAChB;;AAEA;AACA,eAAeH,iBAAiBA,CAACU,SAAS,EAAE;EAC1C,IAAI;IACF;IACA,MAAMO,KAAK,GAAGP,SAAS,CAACE,QAAQ,CAACnB,GAAG,CAAC,GAAGiB,SAAS,CAACQ,OAAO,CAACzB,GAAG,CAAC,GAAGA,GAAG,CAACK,MAAM,GAAG,CAAC;IAE/E,IAAIqB,UAAU,GAAGT,SAAS,CAACU,SAAS,CAACH,KAAK,EAAEP,SAAS,CAACQ,OAAO,CAAC,GAAG,EAAED,KAAK,CAAC,CAAC;IAC1E,MAAMI,aAAa,GAAG,CAAC,aAAa,EAAE,eAAe,EAAE,UAAU,CAAC;IAElE,IAAI,CAACF,UAAU,CAACP,QAAQ,CAAClB,KAAK,CAAC,EAAE;MAC/ByB,UAAU,GAAGzB,KAAK,GAAGyB,UAAU;IACjC;IACA,MAAMG,gBAAgB,GAAG,IAAIR,GAAG,CAACK,UAAU,CAAC;IAE5C,MAAMI,QAAQ,GAAGD,gBAAgB,CAACC,QAAQ;IAC1C,IAAIC,QAAQ,GAAG,KAAK;IACpBH,aAAa,CAACI,KAAK,CAAEC,UAAU,IAAK;MAClC,IAAIH,QAAQ,KAAKG,UAAU,EAAE;QAC3BF,QAAQ,GAAG,IAAI;QACf,OAAO,KAAK;MACd;IACF,CAAC,CAAC;IACF,OAAOA,QAAQ;EACjB,CAAC,CAAC,OAAOlB,CAAC,EAAE;IACV,OAAO,KAAK;EACd;AAEF;AAEA,SAAST,wBAAwBA,CAAC8B,MAAM,EAAE;EACxC,OAAOA,MAAM,CAACf,QAAQ,CAAC,MAAM,CAAC,IAAIe,MAAM,CAACf,QAAQ,CAAC,KAAK,CAAC;AAC1D"},"metadata":{},"sourceType":"module","externalDependencies":[]}