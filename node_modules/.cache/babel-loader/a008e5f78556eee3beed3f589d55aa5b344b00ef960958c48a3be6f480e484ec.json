{"ast":null,"code":"export const actions = {\n  // set 'devMode' to true inside settings/index.js to use syncPlaylist\n  syncPlaylist(index = 0) {\n    if (this.playlists.length === 0) {\n      console.warn('no playlists ):');\n      return;\n    }\n    // Initialize both user and hidden playlist\n    this.currentPlaylist = [...this.playlists[index].playlist];\n    if (!this.currentVideo.videoId) {\n      const songIndex = getRandomInt(0, this.currentPlaylist.length);\n      this.changeVideoByIndex(songIndex);\n    }\n  },\n  setCurrentPlaylist(playlist) {\n    this.currentPlaylist = playlist;\n  },\n  clearPlaylist() {\n    this.currentPlaylist = [];\n  },\n  shuffleCurrentPlaylist() {\n    this.currentPlaylist = shuffleArray(this.currentPlaylist);\n  },\n  changeVideoByIndex(index = 0) {\n    let video;\n    if (this.currentPlaylist.length === 0) {\n      console.warn('out of songs!');\n      return;\n    }\n    if (index < this.currentPlaylist.length) {\n      video = this.currentPlaylist[index];\n      this.currentIndex = index;\n    } else {\n      video = this.currentPlaylist[0];\n      this.currentIndex = 0;\n    }\n    this.currentVideo = video;\n  },\n  changeCurrentVideoByVideo(video) {\n    if (!video || Object.keys(video).length === 0) {\n      console.warn('no video provided');\n    }\n    this.currentVideo = video;\n  },\n  removeVideoByVideoId(videoId) {\n    const video = this.currentPlaylist.find(video => video.videoId === videoId);\n    const index = this.currentPlaylist.indexOf(video);\n    // Index is returned as -1 if no matching video is found\n    if (index >= 0) {\n      this.currentPlaylist.splice(index, 1);\n    }\n  },\n  addVideoToEnd(video) {\n    const newVideo = {\n      ...video\n    };\n    this.currentPlaylist = [...this.currentPlaylist, newVideo];\n  },\n  addVideoToFirst(video) {\n    this.currentPlaylist = [video, ...this.currentPlaylist];\n  },\n  loadPlaylistWithPayload(payload) {\n    payload.items.forEach(item => {\n      const isDuplicateVideo = this.currentPlaylist.some(video => {\n        if (video.videoId === item.contentDetails.videoId) {\n          return true;\n        }\n      });\n      if (!isDuplicateVideo) {\n        const video = {};\n        video.videoId = item.contentDetails.videoId;\n        video.name = item.snippet.title;\n        this.addVideoToEnd(video);\n      }\n    });\n  }\n};\n// Helpers - thx chatgpt <3\n// min - Inclusive\n// max - Exclusive\nfunction getRandomInt(min = 0, max) {\n  if (!max) {\n    console.warn('max warning');\n  }\n  return Math.floor(Math.random() * (max - min) + min);\n}\nfunction shuffleArray(arr) {\n  const shuffledArray = [...arr];\n  for (let i = shuffledArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    // Can't use destructuring here because it will cause some weird bug, so used a temp value instead\n    // ie: referenceError: can't access j before initialization\n    const tempValue = shuffledArray[j];\n    shuffledArray[j] = shuffledArray[i];\n    shuffledArray[i] = tempValue;\n  }\n  return shuffledArray;\n}","map":{"version":3,"names":["actions","syncPlaylist","index","playlists","length","console","warn","currentPlaylist","playlist","currentVideo","videoId","songIndex","getRandomInt","changeVideoByIndex","setCurrentPlaylist","clearPlaylist","shuffleCurrentPlaylist","shuffleArray","video","currentIndex","changeCurrentVideoByVideo","Object","keys","removeVideoByVideoId","find","indexOf","splice","addVideoToEnd","newVideo","addVideoToFirst","loadPlaylistWithPayload","payload","items","forEach","item","isDuplicateVideo","some","contentDetails","name","snippet","title","min","max","Math","floor","random","arr","shuffledArray","i","j","tempValue"],"sources":["X:/Coding/temp/MyTube/src/store/playlist/actions.js"],"sourcesContent":["export const actions = {\r\n  // set 'devMode' to true inside settings/index.js to use syncPlaylist\r\n  syncPlaylist(index = 0) {\r\n    if (this.playlists.length === 0) {\r\n      console.warn('no playlists ):')\r\n      return\r\n    }\r\n    // Initialize both user and hidden playlist\r\n    this.currentPlaylist = [...this.playlists[index].playlist]\r\n\r\n    if (!this.currentVideo.videoId) {\r\n      const songIndex = getRandomInt(0, this.currentPlaylist.length)\r\n      this.changeVideoByIndex(songIndex)\r\n    }\r\n  },\r\n  setCurrentPlaylist(playlist) {\r\n    this.currentPlaylist = playlist\r\n  },\r\n  clearPlaylist() {\r\n    this.currentPlaylist = []\r\n  },\r\n  shuffleCurrentPlaylist() {\r\n    this.currentPlaylist = shuffleArray(this.currentPlaylist)\r\n  },\r\n  changeVideoByIndex(index = 0) {\r\n    let video\r\n    if (this.currentPlaylist.length === 0) {\r\n      console.warn('out of songs!')\r\n      return\r\n    }\r\n\r\n    if (index < this.currentPlaylist.length) {\r\n      video = this.currentPlaylist[index]\r\n      this.currentIndex = index\r\n    } else {\r\n      video = this.currentPlaylist[0]\r\n      this.currentIndex = 0\r\n    }\r\n    this.currentVideo = video\r\n  },\r\n  changeCurrentVideoByVideo(video) {\r\n    if (!video || Object.keys(video).length === 0) {\r\n      console.warn('no video provided')\r\n    }\r\n    this.currentVideo = video\r\n  },\r\n  removeVideoByVideoId(videoId) {\r\n    const video = this.currentPlaylist.find(video => video.videoId === videoId)\r\n    const index = this.currentPlaylist.indexOf(video)\r\n    // Index is returned as -1 if no matching video is found\r\n    if (index >= 0) {\r\n      this.currentPlaylist.splice(index, 1)\r\n    }\r\n  },\r\n  addVideoToEnd(video) {\r\n    const newVideo = {\r\n      ...video\r\n    }\r\n    this.currentPlaylist = [...this.currentPlaylist, newVideo]\r\n  },\r\n  addVideoToFirst(video) {\r\n    this.currentPlaylist = [video, ...this.currentPlaylist]\r\n  },\r\n  loadPlaylistWithPayload(payload) {\r\n    payload.items.forEach((item) => {\r\n      const isDuplicateVideo = this.currentPlaylist.some((video) => {\r\n        if (video.videoId === item.contentDetails.videoId) {\r\n          return true\r\n        }\r\n      })\r\n      if (!isDuplicateVideo) {\r\n        const video = {}\r\n        video.videoId = item.contentDetails.videoId\r\n        video.name = item.snippet.title\r\n        this.addVideoToEnd(video)\r\n      }\r\n    })\r\n  }\r\n}\r\n// Helpers - thx chatgpt <3\r\n// min - Inclusive\r\n// max - Exclusive\r\nfunction getRandomInt(min = 0, max) {\r\n  if (!max) {\r\n    console.warn('max warning')\r\n  }\r\n  return Math.floor(Math.random() * (max - min) + min)\r\n}\r\nfunction shuffleArray(arr) {\r\n  const shuffledArray = [...arr]\r\n  for (let i = shuffledArray.length - 1; i > 0; i--) {\r\n    const j = Math.floor(Math.random() * (i + 1))\r\n    // Can't use destructuring here because it will cause some weird bug, so used a temp value instead\r\n    // ie: referenceError: can't access j before initialization\r\n    const tempValue = shuffledArray[j]\r\n    shuffledArray[j] = shuffledArray[i]\r\n    shuffledArray[i] = tempValue\r\n  }\r\n  return shuffledArray\r\n}\r\n\r\n\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}